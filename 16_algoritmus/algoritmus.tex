\documentclass{beamer}
\usepackage{fourier}
\usepackage{multicol}
\setlength{\columnsep}{2.5cm}

% add these two lines to your long preamble    
\DeclareMathAlphabet{\mathcal}{OMS}{cmsy}{m}{n}
\SetMathAlphabet{\mathcal}{bold}{OMS}{cmsy}{b}{n}
\newcommand{\bigO}{\mathcal{O}}

\usetheme{Madrid}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage[czech]{babel}
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[amogus]{Algoritmus} % The short title appears at the bottom of every slide, the full title is only on the title page

\author{Jáchym Löwenhöffer} % Your name
\institute[GEVO] % Your institution as it will appear on the bottom of every slide, may be shorthand to save space
{
Gynekologická Evaluace Velkých Obrazů \\ % Your institution for the title page
\medskip
\textit{jachym.lowenhoffer@gmail.com} % Your email address
}
\date{\today} % Date, can be changed to a custom date

\graphicspath{{./pics/}}

\AtBeginSection[]
{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\begin{document}

\begin{frame}
	\titlepage % Print the title page as the first slide
\end{frame}

\begin{frame}
	\frametitle{\href{https://ksp.mff.cuni.cz/encyklopedie/zakladni-algoritmy/}{Přehled}} % Table of contents slide, comment this block out to remove it
	\tableofcontents % Throughout your presentation, if you choose to use \section{} and \subsection{} commands, these will automatically be printed on this slide as an overview of your presentation
\end{frame}

%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------
\section{Logaritmus algoritmus v těle mám... rytmus}
\label{sec:turingus}


\begin{frame}
	\frametitle{\href{https://youtu.be/I9Vd6JP5D_0?si=Sj5GlSdduG39T4ZT}{Co to je?}}
Formální definice algoritmu je složitější, ale intuitivní úplně stačí:
\begin{block}{Algoritmus}
 Posloupnost dostatečně jednoduchých kroků s proveditelných kroků, které řeší
 nějaký problém v konečném čase. 
\end{block}
V těch "dostatečně jednoduchých krocích" je problém, protože hodně záleží na tom
kdo bude ten příslušný algoritmus číst a vyhodnocovat.

\textbf{Příklady:}
\begin{itemize}
 \item Recept v kuchařce
 \item Navigace v telefonu
 \item Program v Pythonu
 \item Čistá binárka
 \item Návod na složení nábytku
\end{itemize}


 \end{frame}

\begin{frame}
 \frametitle{Kdo to čte?}

 Pro počítače píšeme jiné algoritmy než pro lidi.
\vfill
 V obou případech se ale algoritmus \textbf{překládá} než se reálně vyhodnotí
 (až třeba na binárku ta už se rovnou spustí). Musíme brát v potaz kdo nebo co
 náš algoritmus překládá abychom ho napsali dobře. 
\vfill
 Na chybu při kompilování (překládání do jednodušších instrukcí) u algoritmů pro
 lidi často narazíme až pozdě nebo dokonce nikdy.
\end{frame}


\begin{frame}
 \frametitle{Co znamená dobrý algoritmus?}
Algoritmy potřebujeme porovnávat. Kritérií může být hodně, zkuste vymyslet to
\textbf{nejlepší}. Nejintuitivnějším kritériem je prostě absolutní čas za který
program doběhne. Ten je v praxi samozřejmě důležitý, ale je závislý na
parametrech stroje a dalších faktorech, což nechceme.
\vfill
Proto pro účely teoretické informatiky měříme rychlost algoritmus vůči velikosti vstupu. Tedy když
dostane $n$ čísel na vstupu a sečte je dohromady tak provedl $\bigO(n)$ operací.
\vfill
Důležité je u výpočtu časové složitosti pamatovat, že uvažujeme ten nejhorší
případ možný. Je programátorovou úlohou hledat ty nejhorší vstupy a z nich
určit asymptotickou časovou složitost (neboli $\bigO$).

\end{frame}

\subsection{Rychlost algoritmu}
\label{ssec:rychlost-algoritmu}


\begin{frame}{Definice $\bigO$}

Jak bude jasné z definice níže, symbol $\bigO$ se používá jako horní odhad
nějakého algoritmu. Je tedy pravda že program na sčítání provedl taky
$\bigO(n^{n!})$ kroků. Ale samozřejmě se snažíme najít co nejmenší horní
hranici.

\vfill
\begin{block}{Technická definice $\bigO$}
Do třídy $\bigO(g)$ patří všechny funkce $f$ pro které existuje $c \in
\mathbb{R}$ takové že $f \leq cg$ platí až na konečně mnoho výjimek.
\end{block}
\end{frame}

\begin{frame}{Ukázky mainstream $\bigO$}
Když uvádíme rychlost našeho algoritmu často co nejvíc zjednodušujeme výraz
kterým ho odhadujeme. To vedlo až k tomu že se vytvořili nějaké nejpoužívanější
třídy algoritmů podle časové složitosti. 

\centering
\includegraphics[scale=0.16]{bigo.png}
 \end{frame}

\begin{frame}
\frametitle{A co prostorová složitost?}
Krom toho jak dlouho algoritmus běží je občas taky důležité kolik místa v paměti
zabere. Tuto velikost taky uvádíme relativně k velikosti vstupu.

\vfill

Moderní programovací jazyky za nás ty očividné prasárny s pamětí zpravují ale
při vymýšlení algoritmu stojí za letmou úvahu.
\end{frame}

\begin{frame}{Příklad}
 Časovou složitost si ukážeme na třídících algoritmech. Představte si, že jste
 dostali neseřízený seznam hodnot které mezi sebou dokážete porovnávat a vy je
 chcete seřadit od nejmenší po největší. Jak na to? možností je víc:

 \begin{itemize}
  \item \textbf{Miracle sort} - zkouší opravdu každou možnost $\bigO(
   n!)$.
  \item \textbf{Buble sort} - vezme každý prvek a porovná ho s každým ještě
   nesrovnaným tedy v nejhorším případě $\bigO(n^2)$.
  \item \textbf{Quicksort} - podle prostředního prvku intervalu setřídí každou
   půlku a rekurzivně pokračuje v každé půlce -  $\bigO(n^2)$.
 \end{itemize}
\end{frame}

\subsection{Flow-chart}
\label{sec:fde-cycle}

\begin{frame}
 \frametitle{Co to asi bude?}
 Bro co viděl mojí sick flow byl jako: "tpc to si musím načrtnout".
 \vfill
 \begin{block}{Flowchart}
  Jde o způsob jak zjednodušit komplikovanější strukturu tak aby byli jasně
  vidět které kroky na sobě závisí a kde se různé průchody můžou větvit na
  základě nějaké podmínky.
   \end{block}
 \vfill
   Flowcharty se používají při designování algoritmů. Je jen na nás s jakou
   přesností je budeme dělat. 
 
 \end{frame}

 \begin{frame}
  Příklady dvou přesností flowchartů:

  \begin{multicols}{2}
    \includegraphics[scale=0.25]{fcě.png}
   \columnbreak
    \includegraphics[scale=0.5]{fc.png}

  \end{multicols}
 \end{frame}

 \begin{frame}{Převod mezi do kódu}

  Když už si uděláme flowchart toho jak náš program bude fungovat, tak teď je na
  řadě samotné programování. Kód pro kontrolu věku z minulého slidu můžeme
  naprogramovat například:

  \includegraphics[scale=0.5]{Screenshot_2025-02-12-17-18-37_1920x1080.png}
  
 \end{frame}

 \section{Programátorské techniky}
 \label{sec:programatorske-techniky}

 
\subsection{Rekurze}
\label{ssec:rekurze}


 \begin{frame}{Rekurze}
  Věc které se děje v programování docela často je, že jedna funkce volá samu
  sebe. To by na flowchartu vypadalo tak, že z jednoho políčka vede šipka do
  toho samého políčka. Důležité je mít na paměti, že rekurze musí mít nějakou
  podmínku při které se zastaví jinak nikdy nedoběhne.
\vfill
  Ideální příklad je hledání Fibonacciho čísel. Když dostaneme na vstupu $n$ tak
  to definujeme jako součet té stejné funkce pro vstupy $n-1$ a $n-2$. Přičemž
  musíme dodefinovat $F(0)=0$ a $F(1)=1$.

  \includegraphics[scale=0.35]{Screenshot_2025-02-11-20-13-03_1920x1080.png}

  Nejlepší část rekurze je, že ji z pravidla nechceme a ani nemusíme používat,
  často se dá nahradit while loopem. Zkuste to pro Fibonacciho čísla.
 \end{frame}
\subsection{Rozděl a panuj}
\label{ssec:rozdel-a-panuj}


 \begin{frame}{Rozděl a panuj}
  Omg tento problém je tak těžký, co kdybych si ho rozdělil na spoustu malých
  částí, které už dokážu vyřešit jednoduše a potom dal všechny ty řešení
  dohromady? To by ale znamenalo že jsem problém rozdělil a panoval. :sunglass
  emoji:
\vfill
A protože neexistují jiné algoritmu než ty řadící ukážeme si to na merge sortu:

Místo abychom seřadili velký pole tak si to rozdělíme až dojdeme do jednotlivých
elementů které jsou ofc každý seřazený a potom vždy spojíme dvě sousední pole
tak aby výsledek zůstal seřazení což je ez.
 
\end{frame}

\begin{frame}{Ukázka merge sortu}
 \includegraphics[scale=0.4]{mergesort.png}
\end{frame}
\subsection{Hlad}
\label{ssec:hlad}


\begin{frame}{Hladovost}
 Co když řešení komplexního a složitého problému jako celku je na mě prostě moc?
 Co kdybych prostě v každém kroku mohl vybrat to, co zni nejlíp a doufal že se
 dostanu do cíle?
\vfill
 Třeba když chci najít nejkratší cestu z A do B, tak prostě můžu vzít tu
 nejkratší ulici na každé křižovatce žejo?
\vfill
 Příklad této myšlenky, jak funguje je například vracení peněz. Dostaneme částku
 kterou máme vydat v mincích. Najdeme největší minci která je menší než daná
 částka, tu vypíšeme a spustíme funkci znova s částka - mince (nemusí vždy
 fungovat, ale naše mince jsou postavené aby to fungovalo). Další příklad je
 Kruskal.
  
\end{frame}

\begin{frame}{Obrázky}
 
 \includegraphics[scale=0.3]{greedy3.jpg}
\end{frame}

\begin{frame}{Dalsi obrazky}
 
 \includegraphics[scale=0.25]{greedy2.jpg}
\end{frame}

\subsection{Backtracking}
\label{ssec:backtracking}


\begin{frame}{Backtracking}
 Backtracking je jen hezké slovo pro brute-force. Nejlépe je myšlenka "vracení
 se" vidět na procházení bludiště. Obecná myšlenka je, že procházíme nějaký
 stavový strom do hloubky.
\vfill
 Jdeme nějakou chodbou dokud nenarazíme na rozcestí nebo na konec chodby.
 Jestliže se jedná o konec vrátíme se na nejbližší rozcestí a zkusíme jinou
 chodbu. Jestliže dorazíme k rozcestí spustíme funkci znova na náhodné chodbě a
 poznačíme si která to je (nepočítáme s existencí cyklů).


\end{frame}
\subsection{Dynamicka}
\label{ssec:dynamicka}


\begin{frame}{Dynamické programování}
 Zakládá se hlavně na tom, že si před spuštěním samotného algoritmu předpočítáme
 nějaké hodnoty a ty nám poté o hodně zrychlí zbytek programu. Samozřejmě musíme
 řešit jestli se to ve výsledku vyplatí.

 Když chceme najít podposloupnost s největším součtem posloupnosti:
 \[
  1,-2,4,5,-1,-5,2,7
 \]
Tak si uděláme seznam $S$ který bude mít na $i$-tém místě součet hodnot 0 až $i$
z původního seznamu. Pak ale součet podposloupnosti z $a$ do $b$ je $S[b]-S[a]$.
\vfill

Celková časová složitost je jen $\bigO(n^2)$ což je o dost lepší než jen naivní
řešení které je $\bigO(n^3)$ (funguje úplně stejně jen součet daného úseku
naivně počítá).
 
\end{frame}

\end{document}
